알림
-

### 알림창(메시지창)

	- 알림창은 실행 중일때만 동작
	- 앱 실행 중일때 사용하면 효율적 

**UIAlertController**

>- ios 8.0 이후부터 새롭게 등장한 컨트롤러
- 알림창: *모달(Modal)*방식 / 사용자의 선택을 입력 받는 용도
- 액션시트창: 모달 방식 아님 / 사용자가 고를 수 있도록 할때 사용됨
- UIAlertController: 메시지 창 담당
- UIAlertAction: 메시지 창에 버튼 구현 

___

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSmQG9XbILJmUhYnE-sZA4ZqY_K_mgo48mdkmENUSE1Sfne2wJunw)

- .destructive - 중요한 내용을 변경하거나 삭제해서 되돌리 수 없는 결정 역할. 빨간색으로 변함

**알림창 메소드(커스텀)**

	  // 알림창
	   static func presentAlertController(target: UIViewController,
	                                      title: String?,
	                                      massage: String?,
	                                      actionStyle: UIAlertActionStyle = UIAlertActionStyle.default, // 기본 적으로 값을 주었지만 바꿔도 상관없음
	                                      cancelBtn: Bool,
	                                      completion: ((UIAlertAction)->Void)?) {
	                                       
	        // 메시지 창 인스턴스 생성                              
	        let alert = UIAlertController(title: title, message: massage, preferredStyle: .alert)
	        
	        // 확인버튼 : handler - (트레일링 클로저 구문) : 전달된 함수나 클로저 실행
	        let okAction = UIAlertAction(title: "확인", style: actionStyle, handler: completion)
	        
	        // 버튼 컨트롤러에 등록
	        alert.addAction(okAction)
	        
	        // 취소 버튼일 경우
	        if cancelBtn {
	        
	            let cancelAction = UIAlertAction(title: "취소", style: actionStyle, handler: completion)
	            
	            alert.addAction(cancelAction)
	        }
	        
	        // 메시지창 실행
	        target.present(alert, animated: true, completion: nil)
	    }
**참고 내용**	    
>	    
*viewDidLoad()*

>- 뷰가 화면에 구현되지 않은 상태에서 화면 전환 시도함
- 뷰 객체가 메모리에만 올라온 상태에서 호출 
- 아직 뷰가 화면에 구현되기 전임!
- viewDidLoad() 메소드 내에 메시지 창 구현시 *런타임 오류* 발생
- *viewDidAppear(_:)*메소드를 이용 - 완전히 화면에 표현된고 난 후에 호출

**확인 버튼 클릭 후 액션 추가**

> ![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQvVYVGqcvqF-HguNuEj67ZypEEdyLzFw58V-U4nlO-UK6DTlsR)
		
	@IBAction func login(_ sender: Any){
    
		    // 메시지 창 인스턴스 생성
		    let alert = UIAlertController(title: "title", message: "message", preferredStyle: .alert)
		    
		    // 확인버튼 : handler - (트레일링 클로저 구문) : 전달된 함수나 클로저 실행
		    let okAction = UIAlertAction(title: "확인", style:.default, handler: {(_) in
		    
		        // 화인 버튼 클릭시 처리할 내용
		        if let tf = alert.textFields?[0] {
		            print("입력 된 값은 \(tf.text!)")
		        }else{
		            print("입력된 값 없음")
		        }
		    })
		    
		    // 버튼 컨트롤러에 등록
		    alert.addAction(okAction)
	
		    // 순차적으로 텍스트 필드 추가하면 됨
		    // 텍스트 필드 추가
		    alert.addTextField(configurationHandler:{ (tf) in
		        // 텍스트 필드의 속성 설정
		        tf.placeholder = "암호입력"
		        tf.isSecureTextEntry = true // 비밀번호 *로 가리기
		        
		    })
		    
	   		self.present(alert, animated: false)   
		}
	
-

>######모달(Modal)- 창이 닫힐 때까지 그 창을 제외한 화면의 다른 부분 무반응
######알림창이 표시되고 있어도 코드는 계속 실행됨!



-
### 로컬 알림

	- 처음 앱을 제작시 앱 내부 코드에 심어놓은 메시지가 전달되는 경우 사용됨 
	- 앱 종료되어 있거나 백그라운 상태일때 메시지 전달 가능
	- 사용자의 관심에서 멀어지는 상황에서 앱으로 주의를 돌리는 목적으로 사용
	- 앱 실행 여부와 상관 없지만 앱 실행 중일 경우 - 알림 창을 사용하는 법이 효율적
	- 스케줄링 

**UserNotification 프레임 워크 이용한 로컬 알림**

- 알림 전용 프레임워크

>1. class **UNMutableNotificationContent** - 알림 콘텐츠 
	* 기본적익 속성
	* 로컬 알림 타이틀, 서브 타이클 및 알림 메시지 설정 가능
	* 배지, 사운드 설정 가능
	* 수정 가능 (UNNotificationContent- 수정 불가능)
	* *title & body* 필수!

>1. class **UNTimeIntervalNotificationTrigger** - 알림 발송 조건
 	* 발생 시간 & 반복 여부 
 	* 시간 단위 - *초단위*
 	* 특정 시간에 알림 메시지 전송 - class **UNCalendarNotificationTrigger** 사용

>1. class **UNNotificationRequest** - 알림 요청
>	* 식별자: 사용자가 어느 알림 메시지를 클릭했는지 식별시 사용

>1. class **UNUserNotificationCenter**
	* 실제 발송 담당
	* 싱글턴 패턴
	* UNNotificationRequest의 인스턴스를 UNUserNotificationCenter의 #add(_:)메소드 이용하여 추가하면 됨
	* UNUserNotificationCenter.current() - 시스템이 제공하는 인스턴스 받는 방법
	* requestAuthorization()메소드 호출 - 사용자에게 알림 설정에 대한 동의 받아야함

**참고 내용**

> application(_:didFinishLaunchingWithOptions:)
> 
* 처음 실행 될때 호출되는 메소드
* 클래스와 리소스들이 모두 *메모리에 로드되고* 아직 앱의 첫화면을 디바이스에 띄우기 *직전* 
* *시작화면이 스크린에 표시되고 있는 동안 호출*
* 사용자에게 동의 받는 것이 이상적이므로 이곳에 코드 작성

> applicationWillResignActive(_:) 
> 
* 앱이 활성화 상태를 잃어버린 경우 실행 되는 메소드

######비활성화 - 사용자가 홈버튼을 눌러 앱을 백그라운드로 보내거나  앱 실행 중에 전화가 오거나 sns가 오는 경우

*코드 참고*

	func applicationWillResignActive(_ application: UIApplication) {
	        if #available(iOS 10.0, *){ // UserNotification 프레임 워크를 이용한 로컬 알림(ios 10 이상) -> ios 10 이상 버전은 if 조건절 실행
	            
	            // 알림 동의 여부 확인
	    		UNUserNotificationCenter.current().getNotificationSettings { settings in
	                if settings.authorizationStatus == UNAuthorizationStatus.authorized{
	                
	                    // 알림 콘텐츠 인스턴스
	                    let nContent = UNMutableNotificationContent()
	                    nContent.badge = 1
	                    nContent.title = "로컬 알림 메시지"
	                    nContent.subtitle = "다시 열어주세요~"
	                    nContent.body = "왜 나갔어요! 다시 들와 주세요~"
	                    nContent.sound = UNNotificationSound.default()
	                    nContent.userInfo = ["name":"가나다"]
	                    
                    // 알림 발송 조건 인스턴스
                    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
                    
                    // 알림 요청 인스턴스
                    // 식별 아이디: 여러 개의 알림 요청 중에서 원하는 것을 식별하는 용도
                    let request = UNNotificationRequest(identifier: "일어나", content: nContent, trigger: trigger)
                    
                    // 노티피케이션 센터에 추가
                    UNUserNotificationCenter.current().add(request)
                } else{
                    print("사용자가 동의 하지 않음")
                }
            }
            
        }else{ // ios 9이하 UILocalNotification 이용
            
        }
    }

*진행 순서*
> 1. 사용자로 부터 알림 허용 여부 묻기
> 2. 알림 콘텐츠 인스턴스 생성
> 3. 앱 아이콘에 표시될 배지 값 = 1
> 4. 타이틀과 바디 입력
> 5. 알림 메시지 설정
> 6. 사운드 속성 설정

-

### 푸시 알림(서버 알림)

	- 서버 푸시는 앱 서비스 운영자가 필요한 시점에 인스턴스 메시지를 날리는 기능이 있어 마케팅 수단이 되기도 함
	- APNs(Apple Push Notification Service): 애플 고유 메시징 시스템에게 보낸 메시지가 *네트워크*를 통해 전달됨