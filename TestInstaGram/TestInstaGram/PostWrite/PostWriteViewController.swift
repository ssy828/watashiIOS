//
//  PostWriteViewController.swift

import UIKit
import Firebase
import PKHUD

class PostWriteViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    @IBOutlet weak var collectionView: UICollectionView?
    var isUploading = false {
        didSet{
            if isUploading {
                HUD.show(.progress)
            } else {
                HUD.hide()
            }
        }
    }
    
    enum BtnTag: Int{
        case camera = 1
        case gallary
        case upload
    }
    
    var imageUrls = [URL]()
    let uploadSemaphore = DispatchSemaphore(value: 1)
    var uploadIndex = 0
    var autoGeneratedKey: String = ""
    var uploadSuccessImageUrls = [String]()
    
    override func viewDidLoad() {
        let layout = UICollectionViewFlowLayout()
        collectionView?.setCollectionViewLayout(layout, animated: true)
        collectionView?.register(PostWriteImageCollectionViewCell.self, forCellWithReuseIdentifier: "cell")
        
        storageClosure = { (metadata: StorageMetadata?, error:Error?) in
            if let error = error {
                print("Uh-oh, an error occurred!")
                // TODO
                self.isUploading = false
                return
            }
            
            guard let downloadURL = metadata?.downloadURL() else {
                // TODO
                self.isUploading = false
                return
            }
            
            self.uploadSuccessImageUrls.append(downloadURL.absoluteString)
            
            if self.imageUrls.count > self.uploadIndex + 1 {
                self.uploadIndex += 1
                DispatchQueue.global().async {
                    Storage.storage().reference().child(self.autoGeneratedKey+"_\(self.uploadIndex)")
                        .putFile(from: self.imageUrls[self.uploadIndex], metadata: nil, completion: self.storageClosure)
                }
            } else {
                if let user = Auth.auth().currentUser {
                    var post = Post()
                    if let nickname = user.displayName {
                        post.userNickname = nickname
                    }
                    post.key = self.autoGeneratedKey
                    post.imageUrls += self.uploadSuccessImageUrls
                    post.uid = user.uid
                    var postDic = post.dictionary
                    
                    let childUpdates = ["/posts/\(self.autoGeneratedKey)": postDic,
                                        "/user-posts/\(user.uid)/\(self.autoGeneratedKey)/": postDic]
                    
                    Database.database().reference().updateChildValues(childUpdates)
                    
                    UIAlertController.present(target: self, msg: "success") {
                        _ in self.dismiss(animated: true, completion: nil)
                    }
                } else {
                    UIAlertController.present(target: self, msg: "fail downloadURL")
                }
                self.isUploading = false
            }
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return imageUrls.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let index = indexPath.row
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)
        
        if let cell = cell as? PostWriteImageCollectionViewCell {
            cell.imageView?.sd_setImage(with: imageUrls[index])
        }
        
        return cell
    }
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        
        return CGSize(width: collectionView.bounds.width / 2, height: collectionView.bounds.width / 2)
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return 0
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 0
    }
    
    // MARK: 버튼
    @IBAction func handleBtn(_ sender: UIButton){
        guard let btnTag = BtnTag(rawValue: sender.tag) else {return}
        switch btnTag {
        case .camera:
            let imagePickerController = UIImagePickerController()
            imagePickerController.delegate = self
            imagePickerController.allowsEditing = true
            imagePickerController.sourceType = .camera
            present(imagePickerController, animated: true)
        case .gallary:
            let imagePickerController = UIImagePickerController()
            imagePickerController.delegate = self
            imagePickerController.allowsEditing = true
            imagePickerController.sourceType = .photoLibrary
            present(imagePickerController, animated: true)
        case .upload:
            if imageUrls.count == 0 {
                
            } else {
                uploadSemaphore.wait()
                if isUploading {
                    // TODO
                    uploadSemaphore.signal()
                    return
                }
                isUploading = true
                uploadSemaphore.signal()
                
                if let _ = Auth.auth().currentUser, let storageClosure = storageClosure {
        
                    let ref = Database.database().reference()
                    autoGeneratedKey = ref.child("posts").childByAutoId().key
                    
                    uploadSuccessImageUrls.removeAll()
                    
                    uploadIndex = 0
                    Storage.storage().reference().child(autoGeneratedKey+"_\(uploadIndex)")
                        .putFile(from: imageUrls[uploadIndex], metadata: nil, completion: storageClosure)
                } else {
                    // TODO
                    isUploading = false
                }
            }
            break
        }
    }
    
    var storageClosure: ((StorageMetadata?,Error?) -> Void)?
    
}

class PostWriteImageCollectionViewCell: UICollectionViewCell {
    weak var imageView: UIImageView?
    override init(frame: CGRect) {
        super.init(frame: frame)
        setUpUI()
    }
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }
    func setUpUI(){
        let imageView = UIImageView()
        self.imageView = imageView
        contentView.addSubview(imageView)
        
        imageView.snp.makeConstraints {
            $0.top.equalTo(contentView)
            $0.leading.equalTo(contentView)
            $0.trailing.equalTo(contentView)
            $0.bottom.equalTo(contentView)
        }
    }
}

// MARK: UIImagePickerControllerDelegate
extension PostWriteViewController: UIImagePickerControllerDelegate{
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {
        if  let url = info[UIImagePickerControllerImageURL] as? URL
        {
            imageUrls.append(url)
            collectionView?.reloadData()
        }
        picker.dismiss(animated: true, completion: nil)
    }
    
}

// MARK: UINavigationControllerDelegate
extension PostWriteViewController: UINavigationControllerDelegate{
    
}
